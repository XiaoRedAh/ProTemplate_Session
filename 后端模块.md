# 前置工作

① 创建项目

空项目添加一个后端模块（SpringBoot3），勾选上需要的依赖

② 自定义响应类RestBean

com/xiaoRed/entity/RestBean.java

```java
@Data
public class RestBean<T> {
    private int status;
    private boolean success;
    private T message;

    public RestBean(int status, boolean success, T message) {
        this.status = status;
        this.success = success;
        this.message = message;
    }

    public static <T> RestBean<T> success(){
        return new RestBean<>(200,true,null);
    }

    public static <T> RestBean<T> success(T data){
        return new RestBean<>(200,true,data);
    }

    public static <T> RestBean<T> failure(int status){
        return new RestBean<>(status,false,null);
    }

    public static <T> RestBean<T> failure(int status, T data){
        return new RestBean<>(status,false,data);
    }
}
```

# 登录登出功能

## SpringSecurity基本配置

com/xiaoRed/config/SecurityConfiguration.java

```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http.
                authorizeHttpRequests()
                .requestMatchers("/api/auth/**").permitAll()//验证相关的请求全部放行
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .loginProcessingUrl("/api/auth/login")
                .successHandler(this::onAuthenticationSuccess)//登录成功时的操作
                .failureHandler(this::onAuthenticationFailure)//登录失败时的操作
                .and()
                .logout()
                .logoutUrl("/api/auth/logout")
                .logoutSuccessHandler(this::onAuthenticationSuccess)//退出登录时的操作
                .and()
                .csrf()
                .disable()
                .and()
                .exceptionHandling()
                .authenticationEntryPoint(this::onAuthenticationFailure)//发生异常时的操作（一般是没权限）
                .and()
                .build();
    }

    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        response.setCharacterEncoding(("utf-8"));
        //将登录成功的响应转换为json格式响应回去
        if(request.getRequestURI().endsWith("/login"))
          response.getWriter().write(JSONObject.toJSONString(RestBean.success("登录成功")));
        //将退出登录成功的响应转换为json格式响应回去
        else if(request.getRequestURI().endsWith("/logout"))
            response.getWriter().write(JSONObject.toJSONString(RestBean.success("退出登录成功")));
    }

    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
        response.setCharacterEncoding(("utf-8"));
        //将登录失败或发生异常（没权限。。。）的响应转换成json格式响应回去
        response.getWriter().write(JSONObject.toJSONString(RestBean.failure(401,exception.getMessage())));
    }

}
```

## 数据库用户信息校验

① 准备用户表

* username，email设置为唯一

![](img/db_account%E8%A1%A8.png)

② 创建对应Account实体类，UserMapper接口，权限校验服务AuthorizeService接口（实现UserDetailsService）及其对应实现类

com/xiaoRed/entity/Account.java

```java
@Data
public class Account {
    long id;
    String username;
    String password;
    String email;
}
```

com/xiaoRed/mapper/UserMapper.java

```java
@Mapper
public interface UserMapper {
    @Select("select * from db_account where username = #{text} or email = #{text}")
    Account findAccountByNameOrEmail(String text);
}
```

com/xiaoRed/service/AuthorizeService.java

```java
public interface AuthorizeService extends UserDetailsService {
    
}

```

com/xiaoRed/service/impl/AuthorizeServiceImpl.java

```java
@Service
public class AuthorizeService implements AuthorizeService {
    @Resource
    UserMapper userMapper;
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        if(username==null)
            throw new UsernameNotFoundException("用户名不能为空");
        Account account=userMapper.findAccountByNameOrEmail(username);
        if(account==null)
            throw new UsernameNotFoundException("用户名或密码错误");
        return User
                .withUsername(account.getUsername())
                .password(account.getPassword())
                .roles("user")
                .build();
    }
}
```

③ SecurityConfiguration中添加自定义的验证服务以及加密密码

com/xiaoRed/config/SecurityConfiguration.java

```java
 @Resource
    AuthorizeService authorizeService;
 @Bean
    public AuthenticationManager authenticationManager(HttpSecurity security) throws Exception {
        //使用自定义的验证服务
        return security
                .getSharedObject(AuthenticationManagerBuilder.class)
                .userDetailsService(authorizeService)
                .and()
                .build();
    }

    @Bean
    public BCryptPasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }
```

## 将用户信息存储在前端

以上的配置实现了登录校验，但有漏洞：
* 即使没有登录，在网址上输入访问的页面，都可以直接到那个页面，登录功能如同虚设
* 页面跳转机制不合理

解决方案：

后端将登录成功的用户信息返回给前端存储，前端根据用户信息制定合理的跳转机制和页面拦截

com/xiaoRed/entity/auth/Account.java

这个AccountUser是存放用户详细信息的，根据不同项目的需求可以进行扩充

```java
/**
 * Account是数据库直接映射的实体类
 * 而这个AccountUser是存放用户详细信息的，根据不同项目的需求可以进行扩充
 */
@Data
public class AccountUser {
    long id;
    String username;
    String email;
}
```

com/xiaoRed/controller/UserController.java

```java
@RestController
@RequestMapping("/api/user")
public class UserController {
     /**
     * prehandle()方法将登录成功的用户详细信息存放在请求体的session中
     * 调用这个接口时，从请求体中拿到用户详细信息
     * 然后直接将它返回给前端，前端就可以很方便地操纵这些信息了
     */
    @GetMapping("/me")
    public RestBean<AccountUser> me(@SessionAttribute("accountUser") AccountUser accountUser){
        return RestBean.success(accountUser);
    }
}
```

com/xiaoRed/interceptor/AuthorizeInterceptor.java

```java
@Component
public class AuthorizeInterceptor implements HandlerInterceptor {
    @Resource
    UserMapper userMapper;

    /**
     * 请求到来之前做处理
     * 不用担心用户没登录，因为如果没登录，在security的过滤器就已经被拦截了
     *
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //从SecurityContext中拿到登录用户的用户信息
        SecurityContext context = SecurityContextHolder.getContext();
        Authentication authentication = context.getAuthentication();
        User user = (User) authentication.getPrincipal();
        String username = user.getUsername();
        AccountUser accountUser = userMapper.findAccountUserByNameOrEmail(username);//一定是可以查到的
        request.getSession().setAttribute("accountUser", accountUser);//往请求体里的session域里丢用户详细信息，让Controller层拿到它
        return true;
    }
}
```

com/xiaoRed/mapper/UserMapper.java

虽然和Account是一样的，但也要区别开，方便后期扩展

```java
 @Select("select * from db_account where username = #{text} or email = #{text}")
    AccountUser findAccountUserByNameOrEmail(String text);
```



## 跨域问题

com/xiaoRed/config/SecurityConfiguration.java

配置跨域相关

```java
 @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http.
                authorizeHttpRequests()
               ...
                .cors()//配置跨域相关
                .configurationSource(this.corsConfigurationSource())
                .and()
                ...
    }

    //跨域配置源
    private CorsConfigurationSource corsConfigurationSource(){
        CorsConfiguration cors = new CorsConfiguration();
        cors.addAllowedOriginPattern("*");//测试的时候可以允许所有的跨域请求，实际上为了安全应该设置为只允许自己服务器的前端
        cors.setAllowCredentials(true);//允许携带cookie
        cors.addAllowedHeader("*");
        cors.addAllowedMethod("*");
        cors.addExposedHeader("*");
        //封装成配置源
        UrlBasedCorsConfigurationSource source =new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**",cors);//注册配置源：所有请求走上面自定义的跨域政策
        return source;
    }
```

## 记住我

com/xiaoRed/config/SecurityConfiguration.java

* 配置“记住我”
* 持久化存储token
  * 注入DataSource数据源
  * JDBC持久化存储的实现（注意filterChain()方法参数要加上）

```java
    ... 
    @Resource
    DataSource dataSource;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http,
                                           PersistentTokenRepository repository) throws Exception {
        return http.
                authorizeHttpRequests()
                ...
                .and()
                .rememberMe()//配置“记住我功能”
                .rememberMeParameter("remember")//参数默认是remember-me,但我的前端写的是remember，因此要配置一下
                .tokenRepository(repository)//持久化存储rememberMe的token，这里使用JDBC存储
                .tokenValiditySeconds(3600 * 24 * 7)//“记住我”token的有效时间设置为7天：3600秒*24小时*7天
                .and()
                ...
    }

    //使用JDBC持久化存储rememberMe的token
    @Bean
    public PersistentTokenRepository tokenRepository(){
        JdbcTokenRepositoryImpl jdbcTokenRepository=new JdbcTokenRepositoryImpl();
        jdbcTokenRepository.setDataSource(dataSource);//配置数据源
        jdbcTokenRepository.setCreateTableOnStartup(true);//首次启动设置为true来创建表，之后设置为false就行
        return jdbcTokenRepository;
    }
    ...
```

# 通过邮箱注册

## 安全性考虑

pom.xml导入以下依赖，对前端传来的参数进行校验

```xml
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

**前端已经做过参数合法性的校验了，后端为何还要校验？**

前端校验可以通过多种手段被绕过

* 通过使用浏览器的开发者工具，在浏览器中修改HTML代码和前端校验规则，攻击者可以提交包含恶意或不合法信息的请求数据。
* 一些用户可能会禁用浏览器中的JavaScript功能，从而使前端校验无法生效，提交不符合要求的请求数据。
* 攻击者可能会使用编写的脚本或程序，在不经过前端页面的情况下，直接提交请求，跳过前端校验。
* 攻击者利用XSS漏洞，向前端页面中注入恶意脚本，从而绕过前端校验，提交非法请求。

后端校验可以对前端校验无法处理的恶意数据或者攻击进行检测和防范，确保请求的合法性和安全性，并且更加精细的校验可以保证数据的正确性。

## 发送验证码

pom.xml导入邮箱和redis相关依赖

```xml
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

application.yaml配置邮箱发送端和redis

```yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/study?characterEncoding=utf-8
    username: root
    password: cronaldo7
    driver-class-name: com.mysql.cj.jdbc.Driver
  # 配置邮箱发送端
  mail:
    host: smtp.163.com
    username: m19925651773@163.com
    password: ZTREXUEQVBAJLDCW
    port: 465
    properties:
     from: m19925651773@163.com
     mail:
       smtp:
         socketFactory:
           class: javax.net.ssl.SSLSocketFactory
  # 配置Redis。不配也行，反正用的是本地的，就是默认配置
  data:
    redis:
      database: 0
      host: localhost
      port: 6379
```


com/xiaoRed/controller/AuthorizeController.java

```java
@Validated//开启验证：虽然前端对各个参数的合法性做过验证了，但是为了安全，后端还是要再做一次验证（前端总是不靠谱的）
@RestController
@RequestMapping("/api/auth")
public class AuthorizeController {

    //邮件地址的正则表达式
    private final String EMAIL_REGEX = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}$";
    @Resource
    AuthorizeService authorizeService;

     //发送验证码
    @PostMapping("/valid-email")
    public RestBean<String> validateEmail(@Pattern (regexp = EMAIL_REGEX) @RequestParam("email") String email,
                                          HttpSession session){
        //需要传入Session的id，不然换个邮箱就绕过我设置的60秒冷却时间
        String s = authorizeService.sendValidateEmail(email, session.getId());
        if(s == null)
            return RestBean.success("邮件已发送，请注意查收");
        else
            return RestBean.failure(400,s);
    }
}
```

com/xiaoRed/mapper/UserMapper.java

```java
 @Insert("insert into db_account(username, password, email) values (#{username}, #{password}, #{email})")
    int createAccount(String username, String password, String email);
```

com/xiaoRed/service/impl/AuthorizeServiceImpl.java

```java
    @Value("${spring.mail.username}")
    String from;
    
    @Resource
    MailSender mailSender;

    @Resource
    StringRedisTemplate stringRedisTemplate;
    /**
     * 1. 生成存放在Redis中的key。先生成出对应的验证码
     * 2. 拿这个key去Redis里面找，如果有这个键值对，那么剩余时间低于2分钟才可以重发验证码，否则不能发送验证码，直接返回false
     * 3. 如果通过上面的判断，则生成验证码，发送验证码到指定邮箱
     * 4. 邮箱和对应的验证码存放到Redis里面，设置过期时间是3分钟。如果发送失败，把Redis里面刚刚插入的删去
     * 5. 用户在注册时，再从Redis里面取出对应键值对，看验证码是否一致
     */
    @Override
    public String sendValidateEmail(String email, String sessionId) {
        //生成存放在Redis中的key
        String key = "email:" + sessionId + ":" + email;
        //生成验证码前，先判断Redis中是否以已经有这个key了
        if(Boolean.TRUE.equals(stringRedisTemplate.hasKey(key))){
            //如果剩余时间大于两分钟，那么不能发送邮件（0L是应付代码走到这，Redis对应key的键值对刚好过期的情况）
            Long expire = Optional.ofNullable(stringRedisTemplate.getExpire(key, TimeUnit.SECONDS)).orElse(0L);
            if(expire > 120)return "请求频繁，请稍后再试";
        }
        if(userMapper.findAccountByNameOrEmail(email)!=null)
            return "此邮箱已被其他用户注册";
        //生成6位验证码
        Random random =new Random();
        int code = random.nextInt(899999) + 100000;//这样保证生成的code一定是6位数
        //封装要发送的邮件
        SimpleMailMessage message=new SimpleMailMessage();
        message.setFrom(from);//配置发送邮件的邮箱
        message.setTo(email);//发送邮件给注册用户填写的邮箱地址
        message.setSubject("您的验证邮箱");//发出去的邮件的标题
        message.setText("验证码："+code);//邮件内容
        try{
            //发送包含验证码的邮件给注册用户填写的邮箱
            mailSender.send(message);
            //往Redis数据库存键值对，有效期是3分钟
            stringRedisTemplate.opsForValue().set(key, String.valueOf(code), 3, TimeUnit.MINUTES);
            return null;
        }catch (MailException e){
            e.printStackTrace();
            return "邮件发送失败，请检查邮箱地址是否有效";
        }
    }
```

## 注册

com/xiaoRed/controller/AuthorizeController.java

```java
    //包含中英文，不含特殊字符的用户名的正则表达式
    private final String USERNAME_REGEX = "^[a-zA-Z0-9\\u4e00-\\u9fa5]+$";
    //验证并注册
    @PostMapping("/register")
    public RestBean<String> registerUser(@Pattern(regexp = USERNAME_REGEX)@Length(min = 2, max =8) @RequestParam("username") String username,
                                         @Length(min = 6, max =16) @RequestParam("password") String password,
                                         @Pattern (regexp = EMAIL_REGEX) @RequestParam("email") String email,
                                         @Length(min = 6, max =6)@RequestParam("code") String code,
                                         HttpSession session){
        String s = authorizeService.validateAndRegister(username, password, email, code, session.getId());
        if(s == null)
            return RestBean.success("注册成功");
        else
            return RestBean.failure(400, s);
    }
```

com/xiaoRed/service/impl/AuthorizeServiceImpl.java

```java
@Override
    public String validateAndRegister(String username, String password, String email, String code, String sessionId) {
        //生成Redis中的key
        String key = "email:" + sessionId + ":" + email;
        //判断Redis是否有这个key
        //有这个key，说明验证码发送过了，才能通过key找验证码进行校验
        if(Boolean.TRUE.equals(stringRedisTemplate.hasKey(key))){
            //从redis中找到对应key的验证码
            String s = stringRedisTemplate.opsForValue().get(key);
            if(s == null) return "验证码失效，请重新请求";//特殊情况：刚找到，验证码就过期了
            //验证码填写正确
            if(s.equals(code)){
                password = encoder.encode(password);//密码需要加密后存储在数据库
                stringRedisTemplate.delete(key);//验证码用完后就要清除掉
                if(userMapper.createAccount(username, password, email) > 0){//插入数据库成功
                    return null;
                }else{//插入数据库失败
                    return "内部错误，请联系管理员";
                }
            }
            //验证码填写错误
            else{
                return "验证码错误，请检查后再提交";
            }
        }
        //Redis中没有对应的key，说明没有发送验证码
        else{
            return "请先请求一封验证码邮件";
        }
    }
```

# 重置密码

## 需求

重置密码分为两个步骤：

1. 通过发送验证码进行认证
2. 如果认证通过，才能重置密码

## 发送验证码

### 强化之前的代码以便复用

注册和重置密码都需要发送验证码，但注册功能要求填入的电子邮箱地址是**未注册**的，重置密码要求填入的电子邮箱是**已注册**的。

之前写的sendValidateEmail()方法只能满足注册功能的发送验证码，满足不了重置密码功能的发送验证码。因此需要对这个方法进行改进，使它能同时满足这两个功能的需求。改完后，相关代码也会有点改动。

**方案**

1. 向sendValidateEmail()方法中多传一个表明是否要求邮箱已注册的boolean类型的参数hasAccount
2. 之后无论是保存/生成的redis的key都要带有这个hasAccount，以区别是注册时发送的验证码还是重置密码时发送的验证码。不能混在一起用
3. 相关代码进行相应微调

**实现**

① com/xiaoRed/service/impl/AuthorizeServiceImpl.java

* 强化sendValidateEmail()
* validateAndRegister()生成的key要带上hasAccount=false

```java
    /**
     * 1. 生成存放在Redis中的key。先生成出对应的验证码
     * 2. 拿这个key去Redis里面找，如果有这个键值对，那么剩余时间低于2分钟才可以重发验证码，否则不能发送验证码，直接返回false
     * 3. 如果邮箱已经注册过，也不能成功发送验证码
     * 4. 如果通过上面的判断，则生成验证码，发送验证码到指定邮箱
     * 5. 邮箱和对应的验证码存放到Redis里面，设置过期时间是3分钟。如果发送失败，把Redis里面刚刚插入的删去
     * 6. 用户在注册时，再从Redis里面取出对应键值对，看验证码是否一致
     */
    @Override
    public String sendValidateEmail(String email, String sessionId, boolean hasAccount) {
        //生成存放在Redis中的key,要求带上hasaccount，防止有人用重置密码的验证码去填注册的验证码（或反过来）
        String key = "email:" + sessionId + ":" + email + ":" + hasAccount;
        //生成验证码前，先判断Redis中是否以已经有这个key了
        if(Boolean.TRUE.equals(stringRedisTemplate.hasKey(key))){
            //如果剩余时间大于两分钟，那么不能发送邮件（0L是应付代码走到这，Redis对应key的键值对刚好过期的情况）
            Long expire = Optional.ofNullable(stringRedisTemplate.getExpire(key, TimeUnit.SECONDS)).orElse(0L);
            if(expire > 120)return "请求频繁，请稍后再试";
        }
        Account account = userMapper.findAccountByNameOrEmail(email);
        //重置密码功能的发送验证码：需要邮箱是已注册的，但却查到空，说明传入的邮箱未注册，不能发送验证码
        if(hasAccount && account==null) return "没有此邮箱地址的账户";
        //注册功能的发送验证码：需要邮箱是未注册的，但却查到了用户，说明传入的邮箱已注册过，不能发送验证码
        if(!hasAccount && account !=null) return "此邮箱已被其他用户注册";
        //生成6位验证码
        Random random =new Random();
        int code = random.nextInt(899999) + 100000;//这样保证生成的code一定是6位数
        //封装要发送的邮件
        SimpleMailMessage message=new SimpleMailMessage();
        message.setFrom(from);//配置发送邮件的邮箱
        message.setTo(email);//发送邮件给注册用户填写的邮箱地址
        message.setSubject("您的验证邮箱");//发出去的邮件的标题
        message.setText("验证码："+code);//邮件内容
        try{
            //发送包含验证码的邮件给注册用户填写的邮箱
            mailSender.send(message);
            //往Redis数据库存键值对，有效期是3分钟
            stringRedisTemplate.opsForValue().set(key, String.valueOf(code), 3, TimeUnit.MINUTES);
            return null;
        }catch (MailException e){
            e.printStackTrace();
            return "邮件发送失败，请检查邮箱地址是否有效";
        }
    }

    @Override
    public String validateAndRegister(String username, String password, String email, String code, String sessionId) {
        //生成Redis中的key，带上false表明这是注册时发送的验证码
        String key = "email:" + sessionId + ":" + email + ":false";
        //判断Redis是否有这个key
        //有这个key，说明验证码发送过了，才能通过key找验证码进行校验
        if(Boolean.TRUE.equals(stringRedisTemplate.hasKey(key))){
            //从redis中找到对应key的验证码
            String s = stringRedisTemplate.opsForValue().get(key);
            if(s == null) return "验证码失效，请重新请求";//特殊情况：刚找到，验证码就过期了
            //验证码填写正确
            if(s.equals(code)){
                //如果用户名被注册过了，也不能成功注册
                Account account = userMapper.findAccountByNameOrEmail(username);
                if(account != null)return "此用户名已被注册，请更换用户名";
                //所有校验都通过后，才可以注册
                password = encoder.encode(password);//密码需要加密后存储在数据库
                stringRedisTemplate.delete(key);//验证码用完后就要清除掉
                if(userMapper.createAccount(username, password, email) > 0){//插入数据库成功
                    return null;
                }else{//插入数据库失败
                    return "内部错误，请联系管理员";
                }
            }
            //验证码填写错误
            else{
                return "验证码错误，请检查后再提交";
            }
        }
        //Redis中没有对应的key，说明没有发送验证码
        else{
            return "请先请求一封验证码邮件";
        }
    }
```

② com/xiaoRed/controller/AuthorizeController.java

对注册功能发送验证码的响应方法微调：

* 为了区别两种发验证码的场景，请求路径改一下
* 调用sendValidateEmail()方法时多传一个参数false

```java
    //注册功能发送验证码
    @PostMapping("/valid-register-email")
    public RestBean<String> validateRegisterEmail(@Pattern (regexp = EMAIL_REGEX) @RequestParam("email") String email,
                                          HttpSession session){
        //需要传入Session的id，不然换个邮箱就绕过我设置的60秒冷却时间
        //注册功能发送验证码要求传入的邮箱是未注册的，因此传入false
        String s = authorizeService.sendValidateEmail(email, session.getId(), false);
        if(s == null)
            return RestBean.success("邮件已发送，请注意查收");
        else
            return RestBean.failure(400,s);
    }
```

③ 因为注册功能发送验证码的响应方法路径改了，前端的请求地址也要同步进行更改

### 实现

com/xiaoRed/controller/AuthorizeController.java

```java
    //重置密码功能发送验证码
    @PostMapping("/valid-reset-email")
    public RestBean<String> validateResetEmail(@Pattern (regexp = EMAIL_REGEX) @RequestParam("email") String email,
                                          HttpSession session){
        //需要传入Session的id，不然换个邮箱就绕过我设置的60秒冷却时间
        //重置密码功能发送验证码要求传入的邮箱是已注册的，因此传入true
        String s = authorizeService.sendValidateEmail(email, session.getId(), true);
        if(s == null)
            return RestBean.success("邮件已发送，请注意查收");
        else
            return RestBean.failure(400,s);
    }
```

## 重置密码

com/xiaoRed/controller/AuthorizeController.java

```java
     /**
     * 1. 发送邮件
     * 2. redis中查验证码是否正确，正确就在Session中存一个标记
     * 3. 用户发起重置密码请求，如果存在标记，就成功重置
     */
    //重置密码第一个步骤：通过邮箱认证
    @PostMapping("/start-reset")
    public RestBean<String> startReset(@Pattern (regexp = EMAIL_REGEX) @RequestParam("email") String email,
                                       @Length(min = 6, max =6)@RequestParam("code") String code,
                                       HttpSession session){
        String s = authorizeService.validateOnly(email, code, session.getId());
        if(s == null){
            //验证成功，往session里存要重置密码的账户
            session.setAttribute("reset-password", email);
            return RestBean.success();
        }else{
            return RestBean.failure(400,s);
        }
    }
    
    //重置密码第二个步骤：认证通过，重置密码
    @PostMapping("do-reset")
    public RestBean<String> doRest(@Length(min = 6, max =16) @RequestParam("password") String password,
                                   HttpSession session){
        //取session里的reset-password
        String email = (String) session.getAttribute("reset-password");
        if(email == null){//如果取出来为空，说明没有做验证
            return RestBean.failure(401,"请先完成邮箱验证");
        }else if(authorizeService.resetPassword(password, email)){//认证成功，则重置密码
            session.removeAttribute("reset-password");//重置成功后，也要把存在session里的东西删掉
            return RestBean.success("密码重置成功");
        }else{
            return RestBean.failure(500, "内部错误，请联系管理员");
        }
    }
```

com/xiaoRed/mapper/UserMapper.java

```java
@Update("update db_account set password = #{password} where email = #{email}")
    int resetPasswordByEmail(String password, String email);
```

com/xiaoRed/service/impl/AuthorizeServiceImpl.java

```java
@Override
    public String validateOnly(String email, String code, String sessionId) {
        //生成Redis中的key，带上true表明这是重置密码时发送的验证码
        String key = "email:" + sessionId + ":" + email + ":true";
        //判断Redis是否有这个key
        //有这个key，说明验证码发送过了，才能通过key找验证码进行校验
        if (Boolean.TRUE.equals(stringRedisTemplate.hasKey(key))) {
            //从redis中找到对应key的验证码
            String s = stringRedisTemplate.opsForValue().get(key);
            if (s == null) return "验证码失效，请重新请求";//特殊情况：刚找到，验证码就过期了
            //验证码填写正确
            if (s.equals(code)) {
                stringRedisTemplate.delete(key);//验证码用完后就要清除掉
                return null;
            }
            //验证码填写错误
            else {
                return "验证码错误，请检查后再提交";
            }
        }
        //Redis中没有对应的key，说明没有发送验证码
        else{
            return "请先请求一封验证码邮件";
        }
    }
@Override
    public boolean resetPassword(String password, String email) {
        password = encoder.encode(password);//密码加密存储在数据库
        return userMapper.resetPasswordByEmail(password, email) > 0;
    }
```
