# 前置工作

① 创建项目

空项目添加一个后端模块（SpringBoot3），勾选上需要的依赖

② 自定义响应类RestBean

com/xiaoRed/entity/RestBean.java

```java
@Data
public class RestBean<T> {
    private int status;
    private boolean success;
    private T message;

    public RestBean(int status, boolean success, T message) {
        this.status = status;
        this.success = success;
        this.message = message;
    }

    public static <T> RestBean<T> success(){
        return new RestBean<>(200,true,null);
    }

    public static <T> RestBean<T> success(T data){
        return new RestBean<>(200,true,data);
    }

    public static <T> RestBean<T> failure(int status){
        return new RestBean<>(status,false,null);
    }

    public static <T> RestBean<T> failure(int status, T data){
        return new RestBean<>(status,false,data);
    }
}
```

# 登录登出功能

## SpringSecurity基本配置

com/xiaoRed/config/SecurityConfiguration.java

```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http.
                authorizeHttpRequests()
                .requestMatchers("/api/auth/**").permitAll()//验证相关的请求全部放行
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .loginProcessingUrl("/api/auth/login")
                .successHandler(this::onAuthenticationSuccess)//登录成功时的操作
                .failureHandler(this::onAuthenticationFailure)//登录失败时的操作
                .and()
                .logout()
                .logoutUrl("/api/auth/logout")
                .logoutSuccessHandler(this::onAuthenticationSuccess)//退出登录时的操作
                .and()
                .csrf()
                .disable()
                .and()
                .exceptionHandling()
                .authenticationEntryPoint(this::onAuthenticationFailure)//发生异常时的操作（一般是没权限）
                .and()
                .build();
    }

    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        response.setCharacterEncoding(("utf-8"));
        //将登录成功的响应转换为json格式响应回去
        if(request.getRequestURI().endsWith("/login"))
          response.getWriter().write(JSONObject.toJSONString(RestBean.success("登录成功")));
        //将退出登录成功的响应转换为json格式响应回去
        else if(request.getRequestURI().endsWith("/logout"))
            response.getWriter().write(JSONObject.toJSONString(RestBean.success("退出登录成功")));
    }

    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
        response.setCharacterEncoding(("utf-8"));
        //将登录失败或发生异常（没权限。。。）的响应转换成json格式响应回去
        response.getWriter().write(JSONObject.toJSONString(RestBean.failure(401,exception.getMessage())));
    }

}
```

## 数据库用户信息校验

① 准备用户表

* username，email设置为唯一

![](img/db_account%E8%A1%A8.png)

② 创建对应Account实体类，UserMapper接口，权限校验服务AuthorizeService接口（实现UserDetailsService）及其对应实现类

com/xiaoRed/entity/Account.java

```java
@Data
public class Account {
    long id;
    String username;
    String password;
    String email;
}
```

com/xiaoRed/mapper/UserMapper.java

```java
@Mapper
public interface UserMapper {
    @Select("select * from db_account where username = #{text} or email = #{text}")
    Account findAccountByNameOrEmail(String text);
}
```

com/xiaoRed/service/AuthorizeService.java

```java
public interface AuthorizeService extends UserDetailsService {
    
}

```

com/xiaoRed/service/impl/AuthorizeServiceImpl.java

```java
@Service
public class AuthorizeService implements AuthorizeService {
    @Resource
    UserMapper userMapper;
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        if(username==null)
            throw new UsernameNotFoundException("用户名不能为空");
        Account account=userMapper.findAccountByNameOrEmail(username);
        if(account==null)
            throw new UsernameNotFoundException("用户名或密码错误");
        return User
                .withUsername(account.getUsername())
                .password(account.getPassword())
                .roles("user")
                .build();
    }
}
```

③ SecurityConfiguration中添加自定义的验证服务以及加密密码

com/xiaoRed/config/SecurityConfiguration.java

```java
 @Resource
    AuthorizeService authorizeService;
 @Bean
    public AuthenticationManager authenticationManager(HttpSecurity security) throws Exception {
        //使用自定义的验证服务
        return security
                .getSharedObject(AuthenticationManagerBuilder.class)
                .userDetailsService(authorizeService)
                .and()
                .build();
    }

    @Bean
    public BCryptPasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }
```

## 将用户信息存储在前端

以上的配置实现了登录校验，但有漏洞：
* 即使没有登录，在网址上输入访问的页面，都可以直接到那个页面，登录功能如同虚设
* 页面跳转机制不合理

解决方案：

后端将登录成功的用户信息返回给前端存储，前端根据用户信息制定合理的跳转机制和页面拦截

com/xiaoRed/entity/auth/Account.java

这个AccountUser是存放用户详细信息的，根据不同项目的需求可以进行扩充

```java
/**
 * Account是数据库直接映射的实体类
 * 而这个AccountUser是存放用户详细信息的，根据不同项目的需求可以进行扩充
 */
@Data
public class AccountUser {
    long id;
    String username;
    String email;
}
```

com/xiaoRed/controller/UserController.java

```java
@RestController
@RequestMapping("/api/user")
public class UserController {
     /**
     * prehandle()方法将登录成功的用户详细信息存放在请求体的session中
     * 调用这个接口时，从请求体中拿到用户详细信息
     * 然后直接将它返回给前端，前端就可以很方便地操纵这些信息了
     */
    @GetMapping("/me")
    public RestBean<AccountUser> me(@SessionAttribute("accountUser") AccountUser accountUser){
        return RestBean.success(accountUser);
    }
}
```

com/xiaoRed/interceptor/AuthorizeInterceptor.java

```java
@Component
public class AuthorizeInterceptor implements HandlerInterceptor {
    @Resource
    UserMapper userMapper;

    /**
     * 请求到来之前做处理
     * 不用担心用户没登录，因为如果没登录，在security的过滤器就已经被拦截了
     *
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //从SecurityContext中拿到登录用户的用户信息
        SecurityContext context = SecurityContextHolder.getContext();
        Authentication authentication = context.getAuthentication();
        User user = (User) authentication.getPrincipal();
        String username = user.getUsername();
        AccountUser accountUser = userMapper.findAccountUserByNameOrEmail(username);//一定是可以查到的
        request.getSession().setAttribute("accountUser", accountUser);//往请求体里的session域里丢用户详细信息，让Controller层拿到它
        return true;
    }
}
```

com/xiaoRed/mapper/UserMapper.java

虽然和Account是一样的，但也要区别开，方便后期扩展

```java
 @Select("select * from db_account where username = #{text} or email = #{text}")
    AccountUser findAccountUserByNameOrEmail(String text);
```



## 跨域问题

com/xiaoRed/config/SecurityConfiguration.java

配置跨域相关

```java
 @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http.
                authorizeHttpRequests()
               ...
                .cors()//配置跨域相关
                .configurationSource(this.corsConfigurationSource())
                .and()
                ...
    }

    //跨域配置源
    private CorsConfigurationSource corsConfigurationSource(){
        CorsConfiguration cors = new CorsConfiguration();
        cors.addAllowedOriginPattern("*");//测试的时候可以允许所有的跨域请求，实际上为了安全应该设置为只允许自己服务器的前端
        cors.setAllowCredentials(true);//允许携带cookie
        cors.addAllowedHeader("*");
        cors.addAllowedMethod("*");
        cors.addExposedHeader("*");
        //封装成配置源
        UrlBasedCorsConfigurationSource source =new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**",cors);//注册配置源：所有请求走上面自定义的跨域政策
        return source;
    }
```

## 记住我

com/xiaoRed/config/SecurityConfiguration.java

* 配置“记住我”
* 持久化存储token
  * 注入DataSource数据源
  * JDBC持久化存储的实现（注意filterChain()方法参数要加上）

```java
    ... 
    @Resource
    DataSource dataSource;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http,
                                           PersistentTokenRepository repository) throws Exception {
        return http.
                authorizeHttpRequests()
                ...
                .and()
                .rememberMe()//配置“记住我功能”
                .rememberMeParameter("remember")//参数默认是remember-me,但我的前端写的是remember，因此要配置一下
                .tokenRepository(repository)//持久化存储rememberMe的token，这里使用JDBC存储
                .tokenValiditySeconds(3600 * 24 * 7)//“记住我”token的有效时间设置为7天：3600秒*24小时*7天
                .and()
                ...
    }

    //使用JDBC持久化存储rememberMe的token
    @Bean
    public PersistentTokenRepository tokenRepository(){
        JdbcTokenRepositoryImpl jdbcTokenRepository=new JdbcTokenRepositoryImpl();
        jdbcTokenRepository.setDataSource(dataSource);//配置数据源
        jdbcTokenRepository.setCreateTableOnStartup(true);//首次启动设置为true来创建表，之后设置为false就行
        return jdbcTokenRepository;
    }
    ...
```

# 通过邮箱注册

## 前置-安全性考虑

pom.xml导入认证相关的依赖

```xml
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

## 发送验证码

pom.xml导入邮箱和redis相关依赖

```xml
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

application.yaml配置邮箱发送端和redis

```yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/study?characterEncoding=utf-8
    username: root
    password: cronaldo7
    driver-class-name: com.mysql.cj.jdbc.Driver
  # 配置邮箱发送端
  mail:
    host: smtp.163.com
    username: m19925651773@163.com
    password: ZTREXUEQVBAJLDCW
    port: 465
    properties:
     from: m19925651773@163.com
     mail:
       smtp:
         socketFactory:
           class: javax.net.ssl.SSLSocketFactory
  # 配置Redis。不配也行，反正用的是本地的，就是默认配置
  data:
    redis:
      database: 0
      host: localhost
      port: 6379
```


com/xiaoRed/controller/AuthorizeController.java

```java
@Validated//开启验证：虽然前端对各个参数的合法性做过验证了，但是为了安全，后端还是要再做一次验证（前端总是不靠谱的）
@RestController
@RequestMapping("/api/auth")
public class AuthorizeController {

    //邮件地址的正则表达式
    private final String EMAIL_REGEX = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}$";
    @Resource
    AuthorizeService authorizeService;

     //发送验证码
    @PostMapping("/valid-email")
    public RestBean<String> validateEmail(@Pattern (regexp = EMAIL_REGEX) @RequestParam("email") String email,
                                          HttpSession session){
        //需要传入Session的id，不然换个邮箱就绕过我设置的60秒冷却时间
        String s = authorizeService.sendValidateEmail(email, session.getId());
        if(s == null)
            return RestBean.success("邮件已发送，请注意查收");
        else
            return RestBean.failure(400,s);
    }
}
```

com/xiaoRed/mapper/UserMapper.java

```java
 @Insert("insert into db_account(username, password, email) values (#{username}, #{password}, #{email})")
    int createAccount(String username, String password, String email);
```

com/xiaoRed/service/impl/AuthorizeServiceImpl.java

```java
    @Value("${spring.mail.username}")
    String from;
    
    @Resource
    MailSender mailSender;

    @Resource
    StringRedisTemplate stringRedisTemplate;
    /**
     * 1. 生成存放在Redis中的key。先生成出对应的验证码
     * 2. 拿这个key去Redis里面找，如果有这个键值对，那么剩余时间低于2分钟才可以重发验证码，否则不能发送验证码，直接返回false
     * 3. 如果通过上面的判断，则生成验证码，发送验证码到指定邮箱
     * 4. 邮箱和对应的验证码存放到Redis里面，设置过期时间是3分钟。如果发送失败，把Redis里面刚刚插入的删去
     * 5. 用户在注册时，再从Redis里面取出对应键值对，看验证码是否一致
     */
    @Override
    public String sendValidateEmail(String email, String sessionId) {
        //生成存放在Redis中的key
        String key = "email:" + sessionId + ":" + email;
        //生成验证码前，先判断Redis中是否以已经有这个key了
        if(Boolean.TRUE.equals(stringRedisTemplate.hasKey(key))){
            //如果剩余时间大于两分钟，那么不能发送邮件（0L是应付代码走到这，Redis对应key的键值对刚好过期的情况）
            Long expire = Optional.ofNullable(stringRedisTemplate.getExpire(key, TimeUnit.SECONDS)).orElse(0L);
            if(expire > 120)return "请求频繁，请稍后再试";
        }
        if(userMapper.findAccountByNameOrEmail(email)!=null)
            return "此邮箱已被其他用户注册";
        //生成6位验证码
        Random random =new Random();
        int code = random.nextInt(899999) + 100000;//这样保证生成的code一定是6位数
        //封装要发送的邮件
        SimpleMailMessage message=new SimpleMailMessage();
        message.setFrom(from);//配置发送邮件的邮箱
        message.setTo(email);//发送邮件给注册用户填写的邮箱地址
        message.setSubject("您的验证邮箱");//发出去的邮件的标题
        message.setText("验证码："+code);//邮件内容
        try{
            //发送包含验证码的邮件给注册用户填写的邮箱
            mailSender.send(message);
            //往Redis数据库存键值对，有效期是3分钟
            stringRedisTemplate.opsForValue().set(key, String.valueOf(code), 3, TimeUnit.MINUTES);
            return null;
        }catch (MailException e){
            e.printStackTrace();
            return "邮件发送失败，请检查邮箱地址是否有效";
        }
    }
```

## 注册

com/xiaoRed/controller/AuthorizeController.java

```java
    //包含中英文，不含特殊字符的用户名的正则表达式
    private final String USERNAME_REGEX = "^[a-zA-Z0-9\\u4e00-\\u9fa5]+$";
    //验证并注册
    @PostMapping("/register")
    public RestBean<String> registerUser(@Pattern(regexp = USERNAME_REGEX)@Length(min = 2, max =8) @RequestParam("username") String username,
                                         @Length(min = 6, max =16) @RequestParam("password") String password,
                                         @Pattern (regexp = EMAIL_REGEX) @RequestParam("email") String email,
                                         @Length(min = 6, max =6)@RequestParam("code") String code,
                                         HttpSession session){
        String s = authorizeService.validateAndRegister(username, password, email, code, session.getId());
        if(s == null)
            return RestBean.success("注册成功");
        else
            return RestBean.failure(400, s);
    }
```

com/xiaoRed/service/impl/AuthorizeServiceImpl.java

```java
@Override
    public String validateAndRegister(String username, String password, String email, String code, String sessionId) {
        //生成Redis中的key
        String key = "email:" + sessionId + ":" + email;
        //判断Redis是否有这个key
        //有这个key，说明验证码发送过了，才能通过key找验证码进行校验
        if(Boolean.TRUE.equals(stringRedisTemplate.hasKey(key))){
            //从redis中找到对应key的验证码
            String s = stringRedisTemplate.opsForValue().get(key);
            if(s == null) return "验证码失效，请重新请求";//特殊情况：刚找到，验证码就过期了
            //验证码填写正确
            if(s.equals(code)){
                password = encoder.encode(password);//密码需要加密后存储在数据库
                stringRedisTemplate.delete(key);//验证码用完后就要清除掉
                if(userMapper.createAccount(username, password, email) > 0){//插入数据库成功
                    return null;
                }else{//插入数据库失败
                    return "内部错误，请联系管理员";
                }
            }
            //验证码填写错误
            else{
                return "验证码错误，请检查后再提交";
            }
        }
        //Redis中没有对应的key，说明没有发送验证码
        else{
            return "请先请求一封验证码邮件";
        }
    }
```

# 重置密码

## 需求

重置密码分为两个步骤：

1. 通过发送验证码进行认证
2. 如果认证通过，才能重置密码

## 发送验证码

### 强化之前的代码以便复用

注册和重置密码都需要发送验证码，但注册功能要求填入的电子邮箱地址是**未注册**的，重置密码要求填入的电子邮箱是**已注册**的。

之前写的sendValidateEmail()方法只能满足注册功能的发送验证码，满足不了重置密码功能的发送验证码。因此需要对这个方法进行改进，使它能同时满足这两个功能的需求。改完后，相关代码也会有点改动。

**方案**

1. 向sendValidateEmail()方法中多传一个表明是否要求邮箱已注册的boolean类型的参数hasAccount
2. 之后无论是保存/生成的redis的key都要带有这个hasAccount，以区别是注册时发送的验证码还是重置密码时发送的验证码。不能混在一起用
3. 相关代码进行相应微调

**实现**

① com/xiaoRed/service/impl/AuthorizeServiceImpl.java

* 强化sendValidateEmail()
* validateAndRegister()生成的key要带上hasAccount=false

```java
    /**
     * 1. 生成存放在Redis中的key。先生成出对应的验证码
     * 2. 拿这个key去Redis里面找，如果有这个键值对，那么剩余时间低于2分钟才可以重发验证码，否则不能发送验证码，直接返回false
     * 3. 如果邮箱已经注册过，也不能成功发送验证码
     * 4. 如果通过上面的判断，则生成验证码，发送验证码到指定邮箱
     * 5. 邮箱和对应的验证码存放到Redis里面，设置过期时间是3分钟。如果发送失败，把Redis里面刚刚插入的删去
     * 6. 用户在注册时，再从Redis里面取出对应键值对，看验证码是否一致
     */
    @Override
    public String sendValidateEmail(String email, String sessionId, boolean hasAccount) {
        //生成存放在Redis中的key,要求带上hasaccount，防止有人用重置密码的验证码去填注册的验证码（或反过来）
        String key = "email:" + sessionId + ":" + email + ":" + hasAccount;
        //生成验证码前，先判断Redis中是否以已经有这个key了
        if(Boolean.TRUE.equals(stringRedisTemplate.hasKey(key))){
            //如果剩余时间大于两分钟，那么不能发送邮件（0L是应付代码走到这，Redis对应key的键值对刚好过期的情况）
            Long expire = Optional.ofNullable(stringRedisTemplate.getExpire(key, TimeUnit.SECONDS)).orElse(0L);
            if(expire > 120)return "请求频繁，请稍后再试";
        }
        Account account = userMapper.findAccountByNameOrEmail(email);
        //重置密码功能的发送验证码：需要邮箱是已注册的，但却查到空，说明传入的邮箱未注册，不能发送验证码
        if(hasAccount && account==null) return "没有此邮箱地址的账户";
        //注册功能的发送验证码：需要邮箱是未注册的，但却查到了用户，说明传入的邮箱已注册过，不能发送验证码
        if(!hasAccount && account !=null) return "此邮箱已被其他用户注册";
        //生成6位验证码
        Random random =new Random();
        int code = random.nextInt(899999) + 100000;//这样保证生成的code一定是6位数
        //封装要发送的邮件
        SimpleMailMessage message=new SimpleMailMessage();
        message.setFrom(from);//配置发送邮件的邮箱
        message.setTo(email);//发送邮件给注册用户填写的邮箱地址
        message.setSubject("您的验证邮箱");//发出去的邮件的标题
        message.setText("验证码："+code);//邮件内容
        try{
            //发送包含验证码的邮件给注册用户填写的邮箱
            mailSender.send(message);
            //往Redis数据库存键值对，有效期是3分钟
            stringRedisTemplate.opsForValue().set(key, String.valueOf(code), 3, TimeUnit.MINUTES);
            return null;
        }catch (MailException e){
            e.printStackTrace();
            return "邮件发送失败，请检查邮箱地址是否有效";
        }
    }

    @Override
    public String validateAndRegister(String username, String password, String email, String code, String sessionId) {
        //生成Redis中的key，带上false表明这是注册时发送的验证码
        String key = "email:" + sessionId + ":" + email + ":false";
        //判断Redis是否有这个key
        //有这个key，说明验证码发送过了，才能通过key找验证码进行校验
        if(Boolean.TRUE.equals(stringRedisTemplate.hasKey(key))){
            //从redis中找到对应key的验证码
            String s = stringRedisTemplate.opsForValue().get(key);
            if(s == null) return "验证码失效，请重新请求";//特殊情况：刚找到，验证码就过期了
            //验证码填写正确
            if(s.equals(code)){
                //如果用户名被注册过了，也不能成功注册
                Account account = userMapper.findAccountByNameOrEmail(username);
                if(account != null)return "此用户名已被注册，请更换用户名";
                //所有校验都通过后，才可以注册
                password = encoder.encode(password);//密码需要加密后存储在数据库
                stringRedisTemplate.delete(key);//验证码用完后就要清除掉
                if(userMapper.createAccount(username, password, email) > 0){//插入数据库成功
                    return null;
                }else{//插入数据库失败
                    return "内部错误，请联系管理员";
                }
            }
            //验证码填写错误
            else{
                return "验证码错误，请检查后再提交";
            }
        }
        //Redis中没有对应的key，说明没有发送验证码
        else{
            return "请先请求一封验证码邮件";
        }
    }
```

② com/xiaoRed/controller/AuthorizeController.java

对注册功能发送验证码的响应方法微调：

* 为了区别两种发验证码的场景，请求路径改一下
* 调用sendValidateEmail()方法时多传一个参数false

```java
    //注册功能发送验证码
    @PostMapping("/valid-register-email")
    public RestBean<String> validateRegisterEmail(@Pattern (regexp = EMAIL_REGEX) @RequestParam("email") String email,
                                          HttpSession session){
        //需要传入Session的id，不然换个邮箱就绕过我设置的60秒冷却时间
        //注册功能发送验证码要求传入的邮箱是未注册的，因此传入false
        String s = authorizeService.sendValidateEmail(email, session.getId(), false);
        if(s == null)
            return RestBean.success("邮件已发送，请注意查收");
        else
            return RestBean.failure(400,s);
    }
```

③ 因为注册功能发送验证码的响应方法路径改了，前端的请求地址也要同步进行更改

### 实现

com/xiaoRed/controller/AuthorizeController.java

```java
    //重置密码功能发送验证码
    @PostMapping("/valid-reset-email")
    public RestBean<String> validateResetEmail(@Pattern (regexp = EMAIL_REGEX) @RequestParam("email") String email,
                                          HttpSession session){
        //需要传入Session的id，不然换个邮箱就绕过我设置的60秒冷却时间
        //重置密码功能发送验证码要求传入的邮箱是已注册的，因此传入true
        String s = authorizeService.sendValidateEmail(email, session.getId(), true);
        if(s == null)
            return RestBean.success("邮件已发送，请注意查收");
        else
            return RestBean.failure(400,s);
    }
```

## 重置密码

com/xiaoRed/controller/AuthorizeController.java

```java
     /**
     * 1. 发送邮件
     * 2. redis中查验证码是否正确，正确就在Session中存一个标记
     * 3. 用户发起重置密码请求，如果存在标记，就成功重置
     */
    //重置密码第一个步骤：通过邮箱认证
    @PostMapping("/start-reset")
    public RestBean<String> startReset(@Pattern (regexp = EMAIL_REGEX) @RequestParam("email") String email,
                                       @Length(min = 6, max =6)@RequestParam("code") String code,
                                       HttpSession session){
        String s = authorizeService.validateOnly(email, code, session.getId());
        if(s == null){
            //验证成功，往session里存要重置密码的账户
            session.setAttribute("reset-password", email);
            return RestBean.success();
        }else{
            return RestBean.failure(400,s);
        }
    }
    
    //重置密码第二个步骤：认证通过，重置密码
    @PostMapping("do-reset")
    public RestBean<String> doRest(@Length(min = 6, max =16) @RequestParam("password") String password,
                                   HttpSession session){
        //取session里的reset-password
        String email = (String) session.getAttribute("reset-password");
        if(email == null){//如果取出来为空，说明没有做验证
            return RestBean.failure(401,"请先完成邮箱验证");
        }else if(authorizeService.resetPassword(password, email)){//认证成功，则重置密码
            session.removeAttribute("reset-password");//重置成功后，也要把存在session里的东西删掉
            return RestBean.success("密码重置成功");
        }else{
            return RestBean.failure(500, "内部错误，请联系管理员");
        }
    }
```

com/xiaoRed/mapper/UserMapper.java

```java
@Update("update db_account set password = #{password} where email = #{email}")
    int resetPasswordByEmail(String password, String email);
```

com/xiaoRed/service/impl/AuthorizeServiceImpl.java

```java
@Override
    public String validateOnly(String email, String code, String sessionId) {
        //生成Redis中的key，带上true表明这是重置密码时发送的验证码
        String key = "email:" + sessionId + ":" + email + ":true";
        //判断Redis是否有这个key
        //有这个key，说明验证码发送过了，才能通过key找验证码进行校验
        if (Boolean.TRUE.equals(stringRedisTemplate.hasKey(key))) {
            //从redis中找到对应key的验证码
            String s = stringRedisTemplate.opsForValue().get(key);
            if (s == null) return "验证码失效，请重新请求";//特殊情况：刚找到，验证码就过期了
            //验证码填写正确
            if (s.equals(code)) {
                stringRedisTemplate.delete(key);//验证码用完后就要清除掉
                return null;
            }
            //验证码填写错误
            else {
                return "验证码错误，请检查后再提交";
            }
        }
        //Redis中没有对应的key，说明没有发送验证码
        else{
            return "请先请求一封验证码邮件";
        }
    }
@Override
    public boolean resetPassword(String password, String email) {
        password = encoder.encode(password);//密码加密存储在数据库
        return userMapper.resetPasswordByEmail(password, email) > 0;
    }
```
